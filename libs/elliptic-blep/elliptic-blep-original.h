#ifndef SIGNALSMITH_ELLIPTIC_BLEP_H
#define SIGNALSMITH_ELLIPTIC_BLEP_H

#include <array>
#include <vector>
#include <complex>

#ifndef M_PI
#	define M_PI 3.14159265358979323846
#endif

namespace signalsmith { namespace blep {

// Generated by design.py
// While redesigning the filter, replace with: #include "design/out/coeffs.h"
template<typename Sample>
struct EllipticBlepCoeffs {
	static constexpr size_t maxIntegrals = 3;
	static constexpr size_t complexCount = 6;
	static constexpr size_t realCount = 2;
	std::array<std::complex<Sample>, complexCount> complexPoles{{
		{Sample(-10.000000000000018), Sample(17.32050807568877)},
		{Sample(-5561.9825585455355), Sample(7721.564144482811)},
		{Sample(-3936.722737570645), Sample(13650.19780181135)},
		{Sample(-2348.139919172614), Sample(17360.27161948123)},
		{Sample(-1177.5927594532213), Sample(19350.80475283612)},
		{Sample(-351.8363400542262), Sample(20192.23851486371)}
	}};
	std::array<Sample, realCount> realPoles{{
		Sample(-19.99999999999999),
		Sample(-6297.997056605768)
	}};
	// Coeffs for direct bandlimited synthesis of a polynomial-segment waveform
	std::array<std::complex<Sample>, complexCount> complexCoeffsDirect{{
		{Sample(-20.137568319637083), Sample(-11.467013467217802)},
		{Sample(-16453.622887215584), Sample(-7298.69713359616)},
		{Sample(7771.017375184153), Sample(9555.136477869532)},
		{Sample(-825.4284981496819), Sample(-6790.77302673455)},
		{Sample(-1529.6256419632844), Sample(2560.172369638269)},
		{Sample(755.24579892029), Sample(-310.3432567202606)}
	}};
	std::array<Sample, realCount> realCoeffsDirect{{
		Sample(-20.1380604524064),
		Sample(10325.399897117604)
	}};
	// Coeffs for cancelling the aliasing from discontinuities in an existing waveform
	std::array<std::complex<Sample>, complexCount> complexCoeffsBlep{{
		{Sample(-0.13756831963707938), Sample(0.07999191657476068)},
		{Sample(-16453.622887215584), Sample(-7298.69713359616)},
		{Sample(7771.017375184153), Sample(9555.136477869532)},
		{Sample(-825.4284981496819), Sample(-6790.77302673455)},
		{Sample(-1529.6256419632844), Sample(2560.172369638269)},
		{Sample(755.24579892029), Sample(-310.3432567202606)}
	}};
	std::array<Sample, realCount> realCoeffsBlep{{
		Sample(-0.13806045240640685),
		Sample(10325.399897117604)
	}};
	// Coeffs for adding an impulse in "residue" (not direct) mode
	std::array<std::complex<Sample>, complexCount> complexCoeffsImpulse{{
		{Sample(-0.0), Sample(0.0)},
		{Sample(-16437.986654210414), Sample(-7224.765894589258)},
		{Sample(7790.757942542475), Sample(9526.642450546504)},
		{Sample(-840.5346697230617), Sample(-6786.810488746716)},
		{Sample(-1524.1587677330679), Sample(2562.995919504876)},
		{Sample(754.6036883967192), Sample(-311.8275441795608)}
	}};
	std::array<Sample, realCount> realCoeffsImpulse{{
		Sample(-0.0),
		Sample(10260.028875848622)
	}};
	// Allpass to make the phase approximately linear
	static constexpr size_t allpassLinearDelay = 12;
	static constexpr size_t allpassOrder = 8;
	std::array<Sample, allpassOrder> allpassCoeffs{{
		Sample(-1.1404019925774542),
		Sample(0.8717712692843811),
		Sample(-0.5414291107410761),
		Sample(0.28401669500648064),
		Sample(-0.12366157348276685),
		Sample(0.044047609267247115),
		Sample(-0.011062973561742056),
		Sample(0.0016011395326086875)
	}};
};

template<class Sample>
struct EllipticBlep {
	using Complex = std::complex<Sample>;
	using Coeffs = EllipticBlepCoeffs<Sample>;
	static constexpr size_t maxBlepOrder = Coeffs::maxIntegrals;

	EllipticBlep(Sample srate=44100, size_t partialStepCount=127) : EllipticBlep(false, srate, partialStepCount) {}

	EllipticBlep(bool direct, Sample srate, size_t partialStepCount=127) : partialStepCount(partialStepCount) {
		Coeffs sCoeffs; // S-plane (continuous time) filter
		Sample hzToAngular = (2*M_PI)/srate;

		// Allocate the lookup table
		partialStepPoles.resize(partialStepCount + 1);

		auto addPole = [&](size_t index, Complex pole, Complex coeff, Complex impulseCoeff){
			// Set up partial powers of the pole (so we can move forward/back by fractional samples)
			for (size_t s = 0; s <= partialStepCount; ++s) {
				Sample partial = Sample(s)/partialStepCount;
				partialStepPoles[s][index] = std::exp(partial*pole*hzToAngular);
			}

			// Impulse coeffs are always direct
			blepCoeffs[0][index] = impulseCoeff*hzToAngular;

			// Integrate to get BLEP coeffs
			Complex blepCoeff = coeff*hzToAngular;
			for (size_t o = 1; o <= maxBlepOrder; ++o) {
				blepCoeff /= pole*hzToAngular; // factor from integrating
				blepCoeffs[o][index] = blepCoeff;
			}
		};
		// For now, just cast real poles to complex ones
		const auto &realCoeffs = (direct ? sCoeffs.realCoeffsDirect : sCoeffs.realCoeffsBlep);
		const auto &realImpulseCoeffs = (direct ? sCoeffs.realCoeffsDirect : sCoeffs.realCoeffsImpulse);
		for (size_t i = 0; i < Coeffs::realCount; ++i) {
			addPole(i, sCoeffs.realPoles[i], realCoeffs[i], realImpulseCoeffs[i]);
		}
		const auto &complexCoeffs = (direct ? sCoeffs.complexCoeffsDirect : sCoeffs.complexCoeffsBlep);
		const auto &complexImpulseCoeffs = (direct ? sCoeffs.complexCoeffsDirect : sCoeffs.complexCoeffsImpulse);
		for (size_t i = 0; i < Coeffs::complexCount; ++i) {
			addPole(i + Coeffs::realCount, sCoeffs.complexPoles[i], complexCoeffs[i], complexImpulseCoeffs[i]);
		}
		reset();
	}
	
	void reset() {
		for (auto &s : state) s = 0;
	}
	
	/// Instantaneous filter output
	Sample get() const {
		Sample sum = 0;
		for (size_t i = 0; i < count; ++i) {
			sum += state[i].real();
		}
		return sum;
	}

	/// Future (â‰¤ 1 sample) filter output (as if we called `.step(samplesInFuture)` before `.get()`)
	Sample get(Sample samplesInFuture) const {
		Sample tableIndex = samplesInFuture*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);

		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];

		Sample sum = 0;
		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			sum += (state[i]*lerpPole).real();
		}
		return sum;
	}

	void add(Sample amount, size_t blepOrder) {
		if (blepOrder > maxBlepOrder) return;
		auto &bc = blepCoeffs[blepOrder];
		for (size_t i = 0; i < count; ++i) {
			state[i] += amount*bc[i];
		}
	}
	
	void add(Sample amount, size_t blepOrder, Sample samplesInPast) {
		if (blepOrder > maxBlepOrder) return;
		
		auto &bc = blepCoeffs[blepOrder];

		Sample tableIndex = samplesInPast*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);

		// move the pulse along in time, the same way as state progresses in .step()
		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];
		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] += bc[i]*lerpPole*amount;
		}
	}

	void step() {
		const auto &poles = partialStepPoles.back();
		for (size_t i = 0; i < count; ++i) {
			state[i] *= poles[i];
		}
	}

	void step(Sample samples) {
		Sample tableIndex = samples*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);
		// We can step forward by > 1 sample
		while (intIndex >= partialStepCount) {
			step();
			intIndex -= partialStepCount;
		}

		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];

		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] *= lerpPole;
		}
	}

private:
	// For now, just treat the real poles as complex ones
	static constexpr size_t count = Coeffs::complexCount + Coeffs::realCount;

	using Array = std::array<Complex, count>;
	Array state;
	std::array<Array, maxBlepOrder + 1> blepCoeffs;
	
	// Lookup table for std::pow(pole, fractional)
	size_t partialStepCount;
	std::vector<Array> partialStepPoles;
};

// Allpass which makes the Elliptic BLEP filter approximately linear-phase
template<typename Sample>
struct EllipticBlepAllpass {
	using Coeffs = EllipticBlepCoeffs<Sample>;
	static constexpr size_t linearDelay = Coeffs::allpassLinearDelay;
	static constexpr size_t order = Coeffs::allpassOrder;

	EllipticBlepAllpass() : coeffs(Coeffs().allpassCoeffs) {}

	void reset() {
		for (auto &s : state) s = 0;
	}
	
	Sample operator()(Sample x0) {
		Sample y = state[0] + x0*coeffs[order - 1];
		for (size_t i = 0; i < order - 1; ++i) {
			Sample coeffA = coeffs[i];
			Sample coeffB = coeffs[order - 2 - i];
			state[i] = state[i + 1] + x0*coeffB - y*coeffA;
		}
		state[order - 1] = x0 - y*coeffs[order - 1];
		return y;
	}
private:
	std::array<Sample, Coeffs::allpassOrder> coeffs;
	std::array<Sample, Coeffs::allpassOrder> state;
};

}} // namespace

#endif // include guard
